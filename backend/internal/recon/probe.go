package recon

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	"project-saam/backend/pkg/utils"
)

// runProbe orchestrates the probing of discovered subdomains.
func (r *ReconOrchestrator) runProbe() error {
	r.Log("üöÄ Starting probing of discovered subdomains...", "")

	// Get all _subs.txt files generated by subdomain discovery
	wildcardSubsFiles, err := r.getProjectWildcardSubdomainsFiles()
	if err != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Could not list wildcard subdomain files: %v. Skipping probing.", err), "")
		return nil
	}

	// Get domains from domain.txt
	singleDomains, err := r.getSingleDomains()
	if err != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Could not read single domains: %v. Skipping probing for single domains.", err), "")
	}

	if len(wildcardSubsFiles) == 0 && len(singleDomains) == 0 {
		r.Log("‚ÑπÔ∏è No subdomain files or single domains found to probe. Skipping probing.", "")
		return nil
	}

	// Create output directories
	httpxDir := filepath.Join(r.ResultsDir, "httpx")
	activeDir := filepath.Join(r.ResultsDir, "active")
	if err := os.MkdirAll(httpxDir, 0755); err != nil {
		return fmt.Errorf("failed to create httpx directory: %w", err)
	}
	if err := os.MkdirAll(activeDir, 0755); err != nil {
		return fmt.Errorf("failed to create active directory: %w", err)
	}

	// --- Process Wildcard Subdomains ---
	for i, subsFile := range wildcardSubsFiles {
		// Extract domain name from filename (e.g., "tesla.com" from "tesla.com_subs.txt")
		domain := strings.TrimSuffix(filepath.Base(subsFile), "_subs.txt")

		subdomains, err := utils.ReadFileLines(subsFile)
		if err != nil {
			r.Log(fmt.Sprintf("‚ö†Ô∏è Could not read subdomains from %s: %v", subsFile, err), "")
			continue
		}
		if len(subdomains) == 0 {
			r.Log(fmt.Sprintf("‚ÑπÔ∏è No subdomains in %s. Skipping probing for this domain.", subsFile), "")
			continue
		}

		r.Log(fmt.Sprintf("\n--- Probing wildcard %d/%d: %s (%d subdomains) ---", i+1, len(wildcardSubsFiles), domain, len(subdomains)), "")

		httpxResults, httpxErr := r.runHttpxProbe(domain, subdomains)
		goProbeResults, goProbeErr := r.runGoProbe(domain, subdomains)

		if httpxErr != nil {
			r.Log(fmt.Sprintf("‚ùå httpx probe failed for %s: %v", domain, httpxErr), "")
		}
		if goProbeErr != nil {
			r.Log(fmt.Sprintf("‚ùå Go probe failed for %s: %v", domain, goProbeErr), "")
		}

		// Merge and save results for this domain
		combinedOutputFile := filepath.Join(httpxDir, fmt.Sprintf("%s_httpx.txt", domain))
		if err := r.mergeAndSaveProbedResults(domain, httpxResults, goProbeResults, combinedOutputFile); err != nil {
			r.Log(fmt.Sprintf("‚ùå Error merging and saving probed results for %s: %v", domain, err), "")
		} else {
			// Extract live subdomains from the combined file
			r.extractLiveSubdomains(domain, combinedOutputFile)
		}
	}

	// --- Process Single Domains from domain.txt ---
	if len(singleDomains) > 0 {
		r.Log(fmt.Sprintf("\n--- Probing %d single domains from domain.txt ---", len(singleDomains)), "")
		httpxResults, httpxErr := r.runHttpxProbe("single_domains", singleDomains)
		goProbeResults, goProbeErr := r.runGoProbe("single_domains", singleDomains)

		if httpxErr != nil {
			r.Log(fmt.Sprintf("‚ùå httpx probe failed for single domains: %v", httpxErr), "")
		}
		if goProbeErr != nil {
			r.Log(fmt.Sprintf("‚ùå Go probe failed for single domains: %v", goProbeErr), "")
		}

		// Merge and save results for single domains
		combinedOutputFile := filepath.Join(httpxDir, "single_domains_httpx.txt")
		if err := r.mergeAndSaveProbedResults("single_domains", httpxResults, goProbeResults, combinedOutputFile); err != nil {
			r.Log(fmt.Sprintf("‚ùå Error merging and saving probed results for single domains: %v", err), "")
		} else {
			// Extract live subdomains from the combined file
			r.extractLiveSubdomains("single_domains", combinedOutputFile)
		}
	}

	r.aggregateProbeResults()

	r.Log("‚úÖ Probing complete for all targets.", "")
	return nil
}

// aggregateProbeResults aggregates all probe results into a single file.
func (r *ReconOrchestrator) aggregateProbeResults() {
	r.Log("üöÄ Aggregating all probe results...", "")

	httpxDir := filepath.Join(r.ResultsDir, "httpx")
	activeDir := filepath.Join(r.ResultsDir, "active")

	// Aggregate httpx results
	allHttpxFile := filepath.Join(httpxDir, "httpx-subs.txt")
	httpxGlob := filepath.Join(httpxDir, "*_httpx.txt")
	cmdStrHttpx := fmt.Sprintf("cat %s 2>/dev/null | anew %s", httpxGlob, allHttpxFile)
	cmdHttpx := exec.CommandContext(r.Ctx, "bash", "-c", cmdStrHttpx)
	outputHttpx, errHttpx := cmdHttpx.CombinedOutput()
	if errHttpx != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Could not aggregate httpx results: %v. Output: %s", errHttpx, string(outputHttpx)), "")
	} else {
		r.Log(fmt.Sprintf("‚úÖ Aggregated all httpx results into %s", allHttpxFile), "")
	}

	// Aggregate active results
	allActiveFile := filepath.Join(activeDir, "active-subs.txt")
	activeGlob := filepath.Join(activeDir, "*_subs.txt")
	cmdStrActive := fmt.Sprintf("cat %s 2>/dev/null | anew %s", activeGlob, allActiveFile)
	cmdActive := exec.CommandContext(r.Ctx, "bash", "-c", cmdStrActive)
	outputActive, errActive := cmdActive.CombinedOutput()
	if errActive != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Could not aggregate active subdomain results: %v. Output: %s", errActive, string(outputActive)), "")
	} else {
		r.Log(fmt.Sprintf("‚úÖ Aggregated all active subdomains into %s", allActiveFile), "")
	}
}

// runHttpxProbe executes httpx for a given list of subdomains and returns live hosts.
func (r *ReconOrchestrator) runHttpxProbe(domain string, subdomains []string) ([]string, error) {
	r.Log(fmt.Sprintf("üî• Running httpx for %s...", domain), "")

	// Write subdomains to a temporary file for httpx -l
	tempInputFile := filepath.Join(os.TempDir(), fmt.Sprintf("httpx_input_%s.txt", domain))
	if err := utils.WriteFileLines(tempInputFile, subdomains); err != nil {
		return nil, fmt.Errorf("failed to write temp httpx input file: %w", err)
	}
	defer os.Remove(tempInputFile)

	// Create a temporary output file for httpx
	tempHttpxOutputFile := filepath.Join(os.TempDir(), fmt.Sprintf("httpx_output_%s.txt", domain))
	defer os.Remove(tempHttpxOutputFile)

	cmd := exec.CommandContext(r.Ctx, "httpx", "-l", tempInputFile, "-o", tempHttpxOutputFile, "-silent", "-t", "100") // -t 100 for 100 concurrent requests

	if err := cmd.Run(); err != nil {
		if r.Ctx.Err() == context.Canceled {
			return nil, context.Canceled
		}
		return nil, fmt.Errorf("httpx execution failed: %w", err)
	}

	// Read results from the temporary httpx output file
	httpxResults, err := utils.ReadFileLines(tempHttpxOutputFile)
	if err != nil {
		return nil, fmt.Errorf("could not read httpx output file: %w", err)
	}

	r.Log(fmt.Sprintf("‚úÖ httpx finished for %s. Found %d live hosts.", domain, len(httpxResults)), "")
	return httpxResults, nil
}

// runGoProbe performs a custom Go-based HTTP/HTTPS probe for a given list of subdomains and returns live hosts.
func (r *ReconOrchestrator) runGoProbe(domain string, subdomains []string) ([]string, error) {
	r.Log(fmt.Sprintf("üî• Running custom Go probe for %s...", domain), "")

	var liveHosts []string
	client := &http.Client{
		Timeout: 5 * time.Second,
		Transport: &http.Transport{
			TLSHandshakeTimeout: 5 * time.Second,
			DisableKeepAlives:   true,
		},
	}

	var mu sync.Mutex // Mutex to protect liveHosts slice
	var wg sync.WaitGroup

	// Use a buffered channel to limit concurrency
	concurrencyLimit := 20 // Adjust as needed
	guard := make(chan struct{}, concurrencyLimit)

	for _, sub := range subdomains {
		select {
		case <-r.Ctx.Done():
			r.Log(fmt.Sprintf("‚èπÔ∏è Go probe stopped for %s.", domain), "")
			return nil, r.Ctx.Err()
		default:
		}

		wg.Add(1)
		guard <- struct{}{} // Acquire a slot
		go func(s string) {
			defer wg.Done()
			defer func() { <-guard }() // Release the slot

			var liveURL string
			// Try HTTPS first
			res, err := client.Get(fmt.Sprintf("https://%s", s))
			if err == nil {
				defer res.Body.Close()
				if res.StatusCode >= 200 && res.StatusCode < 400 {
					liveURL = fmt.Sprintf("https://%s", s)
				}
			} else {
				// Fallback to HTTP
				res, err = client.Get(fmt.Sprintf("http://%s", s))
				if err == nil {
					defer res.Body.Close()
					if res.StatusCode >= 200 && res.StatusCode < 400 {
						liveURL = fmt.Sprintf("http://%s", s)
					}
				}
			}

			if liveURL != "" {
				mu.Lock()
				liveHosts = append(liveHosts, liveURL)
				mu.Unlock()
			}
		}(sub)
	}
	wg.Wait()

	r.Log(fmt.Sprintf("‚úÖ Go probe finished for %s. Found %d live hosts.", domain, len(liveHosts)), "")
	return liveHosts, nil
}

// extractLiveSubdomains extracts domains from the httpx output, sorts them, and saves them to a new file.
func (r *ReconOrchestrator) extractLiveSubdomains(domain, httpxOutputFile string) {
	activeDir := filepath.Join(r.ResultsDir, "active")
	// This directory is created in runProbe, but check just in case
	if _, err := os.Stat(activeDir); os.IsNotExist(err) {
		if err := os.MkdirAll(activeDir, 0755); err != nil {
			r.Log(fmt.Sprintf("‚ö†Ô∏è Could not create active directory, skipping extraction for %s: %v", domain, err), "")
			return
		}
	}

	// Check if the input file exists and is not empty
	info, err := os.Stat(httpxOutputFile)
	if os.IsNotExist(err) || (err == nil && info.Size() == 0) {
		r.Log(fmt.Sprintf("‚ÑπÔ∏è httpx output file for %s is missing or empty. Skipping active subdomain extraction.", domain), "")
		return
	} else if err != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Error checking httpx output file for %s: %v", domain, err), "")
		return
	}

	activeSubsFile := filepath.Join(activeDir, fmt.Sprintf("%s_subs.txt", domain))

	// 1. Get existing active subdomains
	var existingActiveSubs = make(map[string]struct{})
	if _, err := os.Stat(activeSubsFile); !os.IsNotExist(err) {
		content, readErr := ioutil.ReadFile(activeSubsFile)
		if readErr != nil {
			r.Log(fmt.Sprintf("‚ö†Ô∏è Could not read existing active subs file for %s: %v. It will be overwritten.", domain, readErr), "")
		} else {
			for _, line := range strings.Split(string(content), "\n") {
				if trimmed := strings.TrimSpace(line); trimmed != "" {
					existingActiveSubs[trimmed] = struct{}{}
				}
			}
		}
	}

	// 2. Get new active subdomains from the current run
	tempActiveSubsFile := activeSubsFile + ".tmp"
	defer os.Remove(tempActiveSubsFile)
	cmdStr := fmt.Sprintf("cat %s | unfurl domains | sort -u > %s", httpxOutputFile, tempActiveSubsFile)
	cmd := exec.CommandContext(r.Ctx, "bash", "-c", cmdStr)

	r.Log(fmt.Sprintf("üî• Extracting active subdomains for %s...", domain), "")
	output, err := cmd.CombinedOutput()
	if err != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Could not extract active subdomains for %s: %v. Output: %s", domain, err, string(output)), "")
		return
	}

	newContent, err := ioutil.ReadFile(tempActiveSubsFile)
	if err != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Could not read temp active subs file for %s: %v", domain, err), "")
		return
	}

	// 3. Find the truly new active subdomains
	newlyFoundCount := 0
	for _, line := range strings.Split(string(newContent), "\n") {
		if trimmed := strings.TrimSpace(line); trimmed != "" {
			if _, exists := existingActiveSubs[trimmed]; !exists {
				newlyFoundCount++
				existingActiveSubs[trimmed] = struct{}{}
			}
		}
	}

	// 4. Write the combined, unique, and sorted list back to the final file.
	allUniqueActiveSubs := make([]string, 0, len(existingActiveSubs))
	for sub := range existingActiveSubs {
		allUniqueActiveSubs = append(allUniqueActiveSubs, sub)
	}
	sort.Strings(allUniqueActiveSubs)

	if err := utils.WriteFileLines(activeSubsFile, allUniqueActiveSubs); err != nil {
		r.Log(fmt.Sprintf("‚ö†Ô∏è Failed to write final updated active subdomain list for %s: %v", domain, err), "")
		return
	}

	if newlyFoundCount > 0 {
		r.Log(fmt.Sprintf("üéâ Found %d brand new active subdomains for %s! Total is now %d.", newlyFoundCount, domain, len(allUniqueActiveSubs)), "")
	} else {
		r.Log(fmt.Sprintf("‚ú® Active subdomain extraction complete. No new active subdomains found for %s. Total remains %d.", domain, len(allUniqueActiveSubs)), "")
	}
}

// mergeAndSaveProbedResults combines, deduplicates, sorts, and saves the probed results.
func (r *ReconOrchestrator) mergeAndSaveProbedResults(domain string, httpxResults, goProbeResults []string, outputFile string) error {
	// 1. Get existing hosts to compare against
	var existingHosts = make(map[string]struct{})
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		content, readErr := ioutil.ReadFile(outputFile)
		if readErr != nil {
			r.Log(fmt.Sprintf("‚ö†Ô∏è Could not read existing results file for %s: %v. It will be overwritten.", domain, readErr), "")
		} else {
			for _, line := range strings.Split(string(content), "\n") {
				if trimmed := strings.TrimSpace(line); trimmed != "" {
					existingHosts[trimmed] = struct{}{}
				}
			}
		}
	}

	// 2. Combine and deduplicate new results
	newHosts := make(map[string]struct{})
	for _, host := range httpxResults {
		trimmed := strings.TrimSpace(host)
		if trimmed != "" {
			newHosts[trimmed] = struct{}{}
		}
	}
	for _, host := range goProbeResults {
		trimmed := strings.TrimSpace(host)
		if trimmed != "" {
			newHosts[trimmed] = struct{}{}
		}
	}

	// 3. Find the truly new hosts
	newlyFoundCount := 0
	for host := range newHosts {
		if _, exists := existingHosts[host]; !exists {
			newlyFoundCount++
			existingHosts[host] = struct{}{}
		}
	}

	// 4. Write the combined, unique, and sorted list back to the final file.
	allUniqueHosts := make([]string, 0, len(existingHosts))
	for host := range existingHosts {
		allUniqueHosts = append(allUniqueHosts, host)
	}
	sort.Strings(allUniqueHosts)

	if len(allUniqueHosts) == 0 {
		r.Log(fmt.Sprintf("‚ÑπÔ∏è No live hosts found for %s after merging.", domain), "")
		return nil
	}

	if err := utils.WriteFileLines(outputFile, allUniqueHosts); err != nil {
		return fmt.Errorf("failed to write combined probed results for %s: %w", domain, err)
	}

	if newlyFoundCount > 0 {
		r.Log(fmt.Sprintf("üéâ Found %d brand new live hosts for %s! Total is now %d.", newlyFoundCount, domain, len(allUniqueHosts)), "")
	} else {
		r.Log(fmt.Sprintf("‚ú® Probing complete. No new live hosts found for %s. Total remains %d.", domain, len(allUniqueHosts)), "")
	}

	return nil
}

// getProjectWildcardSubdomainsFiles returns a list of paths to all _subs.txt files for the current project.
func (r *ReconOrchestrator) getProjectWildcardSubdomainsFiles() ([]string, error) {
	subsDir := filepath.Join(r.ResultsDir, "subs")
	files, err := ioutil.ReadDir(subsDir)
	if err != nil {
		// If the directory doesn't exist, it means no subdomains were found yet.
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read subs directory: %w", err)
	}

	var subsFiles []string
	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), "_subs.txt") {
			subsFiles = append(subsFiles, filepath.Join(subsDir, file.Name()))
		}
	}
	return subsFiles, nil
}

// getSingleDomains reads the in-scope domains from the project's scope/domain.txt.
func (r *ReconOrchestrator) getSingleDomains() ([]string, error) {
	domainFile := filepath.Join(r.ResultsDir, "scope", "domain.txt")
	if _, err := os.Stat(domainFile); os.IsNotExist(err) {
		return []string{}, nil // No domains is not an error
	}
	content, err := utils.ReadFileLines(domainFile)
	if err != nil {
		return nil, err
	}
	var domains []string
	for _, line := range content {
		trimmed := strings.TrimSpace(line)
		if trimmed != "" {
			domains = append(domains, trimmed)
		}
	}
	return domains, nil
}
